webdeploy - v0.0.0
--------------------------------------------------------------------------------
This project provides a command-line tool for deploying a website on a web
server. It employs NodeJS and libgit2. Configuration for the deployments is kept
in the bare repository's 'config' file.

This project is based off of `gitsync`. See https://git.rserver.us/utils/gitsync.

Primary authors:

    Roger Gee <roger.gee@tulsalibrary.org>

--------------------------------------------------------------------------------
Methodology

This is a lightweight tool that implements a deployment pipeline. The pipeline
operates on the filesystem OR a git repository tree (This is collectively called
the "target tree"). The pipeline's job is to map certain targets within the
target tree to their respective output varients. This can be as simple as
copying a file to an output directory, or converting the contents of the
specified file to a usable/convenient format.

The pipeline process contains two primary steps: build and copy. The build phase
is optional as it involves transforming a target into one or more output targets.

A more granular description of the pipeline follows:

    0.1 Find a webdeploy.config.js file in the target tree. This file is used to
        specify how the project is to be built for deployment. This file should
        be committed into the repository. It is only needed to specify targets
        that need to be built.

    0.2 Load configuration from the repository's config file. If the target tree
        is not a git repository, then this step does nothing. This configuration
        should store settings related to the deployment, which is specific to
        the environment of the git repository.

    1.  Search the target tree recursively for targets matching rules defined by
        the configuration gathered in step 0.

    2.  Build each target.

        All build operations are executed before any deployment is executed. A
        build gets to decide which target(s) it handles based on some criteria
        (e.g. file name pattern match, file content, ETC.)

    3.  Execute the deployment for the set of targets.

        A deployment is executed once to handle all targets. It decides how
        targets are written to the deployment environment. Deployments may
        chain.

--------------------------------------------------------------------------------
Plugins

Plugins are external bits of code that add functionality to webdeploy. They come
in two flavors: build plugins and deployment plugins.

A build plugin transforms a target into one or more output targets. It
receives a "target" object that has the following structure:

    {
        input: Stream, // Stream for reading target content
        targetName: String, // Name of target (i.e. file/blob name)
        sourcePath: String, // Relative path to target
        makeOutputTarget: Function // Generates an output target
    }

The plugin reads the contents of the target from "target.input" and calls
"target.makeOutputTarget() one or more times to produce the output targets. The
call to makeOutputTarget() returns a Stream to which the content of the output
target is written and it takes two optional arguments:

    makeOutputTarget(newTargetPath, recursive) -> Stream

If a "newTargetPath" is specified, then the output target is
repositioned/renamed; note, this string is always a relative path. Otherwise it
keeps the same path and name as the input target. The "recursive" parameter
determines whether or not the output target is recursively processed by the
build plugins again. The default is false, so output targets are not processed.

A deployment plugin performs operations on output targets, which may include
transforming the set of output targets in some way. One deployment plugin is
initiated for a single run; however multiple deployment plugins can chain
together if needed. A deployment plugin receives a "context" object that has the
following structure:

    {
        targets: Array, // The set of targets to process
            // Each has the following structure:
            {
                in: Stream, // Stream for reading target content
                targetName: String, // Name of target (i.e. file/blob name)
                deployPath: String  // Path to deployment location
            }

        makeOutputTarget: Function, // Generates an output target
        chain: Function // Chains the deploy operation to another deployment plugin
    }

The deployment plugin context contains a list of output targets that are ready
to be processed. However a plugin may choose to transform this set of targets by
splicing the array and creating new output targets. The function
"makeOutputTarget" takes a required parameter indicating the new target
path. The "chain" function takes the plugin ID for the next deployment plugin in
the chain:

    makeOutputTarget(newTargetPath)
    chain(pluginName)

These functions can be used, for example, to combine all output targets into
one:

    let i = 0;
    let combined = "";
    let removed = context.targets.splice(0,context.targets.length);
    function combine(chunk) {
        combined += chunk;
    }
    function end() {
        if (++i == removed.length) {
            context.makeOutputTarget("combined.txt").write(combined);
            context.chain("write");
        }
        else {
            removed[i].input.on("data",combine);
            removed[i].input.on("end",end);
        }
    }
    removed[0].input.on("data",combine);
    removed[0].input.on("end",end);

The webdeploy core code (i.e. this repository) comes with several core plugins
already built-in:

    [build]
    pass        - does absolutely nothing to the target

    [deployment]
    exclude     - does absolutely nothing (i.e. excludes all targets from deployment)
    deploy      - writes output targets to the filesystem relative to the deploy path
    build       - writes output targets to the filesystem relative to the build path

The built-in plugins cannot be removed; they perform core operations.

A plugin is implemented as a NodeJS module. It must provide the following object
in its module.exports:

    {
        exec(target | context): Function
    }

The exec() function takes either "target" or "context" objects for build and
deployment plugins respectively. It should return true if the target was
processed in some way.

--------------------------------------------------------------------------------
