webdeploy - v0.0.0
--------------------------------------------------------------------------------
This project provides a command-line tool for deploying a website on a web
server. It employs NodeJS and libgit2. Configuration for the deployments is kept
in the bare repository's 'config' file.

This project is based off of `gitsync`. See https://git.rserver.us/utils/gitsync.

Primary authors:

    Roger Gee <roger.gee@tulsalibrary.org>

--------------------------------------------------------------------------------
Methodology

This is a lightweight tool that implements a deployment pipeline. The pipeline
operates on the filesystem OR a git repository tree (This is collectively called
the "target tree"). The pipeline's job is to map certain targets within the
target tree to their respective output varients. This can be as simple as
copying a file to an output directory, or converting the contents of the
specified file to a usable/convenient format.

The pipeline process contains two primary steps: build and copy. The build phase
is optional as it involves transforming a target into one or more output targets.

A more granular description of the pipeline follows:

    0.1 Find a webdeploy.config.js file in the target tree. This file is used to
        specify how the project is to be built for deployment. This file should
        be committed into the repository. It is only needed to specify targets
        that need to be built.

    0.2 Load configuration from the repository's config file. If the target tree
        is not a git repository, then this step does nothing. This configuration
        should store settings related to the deployment, which is specific to
        the environment of the git repository.

    1.  Search the target tree recursively for targets matching rules defined by
        the configuration gathered in step 0.

    2.  Build each target.

        All build operations are executed before any deployment is executed. A
        build gets to decide which target(s) it handles based on some criteria
        (e.g. file name pattern match, file content, ETC.)

    3.  Execute the deployment for the set of targets.

        A deployment is executed once to handle all targets. It decides how
        targets are written to the deployment environment. Deployments may
        chain.

--------------------------------------------------------------------------------
Command usage

There are two basic, high-level commands: build and deploy. They essentially do
the same thing but refer to alternate configurations.

    $ webdeploy build [path]

        path - source path of tree to deploy; defaults to current directory

      A build runs a deployment without the "build" deployment
      configuration. This basically means it doesn't require a "deploy-path"
      configuration; instead the deploy path is implicitly configured to be the
      same as the build path.

      This is useful for building locally when testing.

      NOTE: A webdeploy.config.js file must still be available.

    $ webdeploy deploy [path]

        path - source path of tree to deploy; defaults to current directory

      Runs a deployment. The tool determines whether "path" refers to a
      git-repository or just a normal directory tree. The semantics of operating
      on a git-repository are different than those operating on a local path. A
      "deploy-path" option must be available.

      This command is really designed for git-repositories, but it can work on
      normal directories also. It is recommened that "deploy-path" is kept in
      git-config for the repository to separate it from the committed
      "webdeploy.config.js" file.

--------------------------------------------------------------------------------
Plugins

Plugins are external bits of code that add functionality to webdeploy. They come
in two flavors: build plugins and deployment plugins.

A build plugin transforms a target into one or more output targets. It
receives a "target" object that has the following structure:

    {
        inputStream: Stream, // Stream for reading target content
        targetName: String,  // Name of target (i.e. file/blob name)
        sourcePath: String,  // Relative path to target
        deployPath: String,  // If set, absolute path to target destination
        makeOutputTarget: Function // Generates an output target
    }

The plugin reads the contents of the target from "target.inputStream" and calls
"target.makeOutputTarget() one or more times to produce the output targets. The
call to makeOutputTarget() returns a Stream to which the content of the output
target is written and it takes three optional arguments:

    makeOutputTarget(newTargetName, newTargetPath, recursive) -> Stream

        newTargetName: the name for the new target; inherits if omitted
        newTargetPath: the path to the new target; inherits if omitted
        recursive: if true, then the target is recursively processed by the build system

A deployment plugin performs operations on output targets, which may include
transforming the set of output targets in some way. One deployment plugin is
initiated for a single run; however multiple deployment plugins can chain
together if needed. A deployment plugin receives a "context" object that has the
following structure:

    {
        targets: Array, // The set of targets to process
        resolveTargets: Function, // Resolves multiple targets into one
        chain: Function // Chains the deploy operation to another deployment plugin
    }

The deployment plugin context contains a list of output targets that are ready
to be processed. However a plugin may choose to transform this set of targets by
resolving one or more targets into a new target. The function "resolveTargets"
converts the specified list of targets into a new target having the specified
path. If new target path is null, then the targets are removed without a
resolution. The function returns a Stream suitable for writing the new target.

    resolveTargets(newTargetPath,targets) -> Stream

The "chain" function takes the plugin ID for the next deployment plugin to be
executed. This is useful to fallback onto existing functionality. Typically, a
custom plugin will chain to the "write" plugin to write the targets to the
filesystem:

    chain(pluginName)

The webdeploy core code (i.e. this repository) comes with several core plugins
already built-in:

    [build]
    pass        - does absolutely nothing to the target

    [deployment]
    exclude     - does absolutely nothing (i.e. excludes all targets from deployment)
    write       - writes output targets to the filesystem relative to the deploy path

The built-in plugins cannot be removed; they perform core operations.

A plugin is implemented as a NodeJS module. It must provide the following object
in its module.exports:

    {
        exec(target | context, plugin): Function
    }

The exec() function takes either "target" or "context" objects for build and
deployment plugins respectively. It should return a Promise that passes the
created target name(s) to its resolve callback. This can be a scalar or an
array.

The second parameter is sent for build plugins to pass in the plugin handler
object defined in webdeploy.config.js. For deploy plugins this is currently
undefined.

--------------------------------------------------------------------------------
Standard plugins

This repository provides several standard plugins that aim to be universal in
application. They are located under the "plugins" subdirectory and take
precedence over any external plugins. However these plugins can be removed
(unlike the build plugins).

Provided plugins:

    minify - minifies JS and CSS
    babel - leverages Babel
